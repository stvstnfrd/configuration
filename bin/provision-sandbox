#!/usr/bin/env python
# -*- coding: utf-8 -*-
# pylint: disable=invalid-name
# pylint: enable=invalid-name
# Yes, the above pylint pragmas disable then immediately reÃ«nable the same check.
# This disables the check for the module/filename, but then turns it back on
# to be enforced elsewhere.
"""
Provision an EC2 instance for use as an OpenEdX sandbox
"""
from __future__ import print_function
import argparse
import os
import sys
import time

from boto.ec2 import EC2Connection


PATH_SCRIPT = __file__
PATH_BIN = os.path.dirname(PATH_SCRIPT)
PATH_PROJECT = os.path.dirname(PATH_BIN)
PATH_PLAYBOOKS = os.path.join(PATH_PROJECT, 'playbooks')


def parse_arguments():
    """
    Parse provided command line arguments, fallback to defaults
    """
    parser = argparse.ArgumentParser(
        description=__doc__,
    )
    parser.add_argument(
        '-a',
        '--ami',
        default='ami-2b2f594b',
        help='(base=ami-2b2f594b, release=ami-5c16513c)',
    )
    parser.add_argument(
        '-c',
        '--create',
        default=False,
        action='store_true',
    )
    parser.add_argument(
        '-d',
        '--disk-size',
        default=16,
        help='the disk size in GB'
    )
    parser.add_argument(
        '--keypair',
        default='deployment',
    )
    parser.add_argument(
        '-l',
        '--list',
        default=True,
        action='store_true',
    )
    parser.add_argument(
        '-n',
        '--name',
        required=True,
    )
    parser.add_argument(
        '-p',
        '--playbook',
        default=os.path.join(PATH_PLAYBOOKS, 'edx_sandbox.yml'),
    )
    parser.add_argument(
        '--repo-platform',
        default='https://github.com/Stanford-Online/edx-platform.git',
    )
    parser.add_argument(
        '--repo-theme',
        default='https://github.com/Stanford-Online/lagunita-theme.git',
    )
    parser.add_argument(
        '-s',
        '--start',
        default=False,
        action='store_true',
    )
    parser.add_argument(
        '-S',
        '--stop',
        default=False,
        action='store_true',
    )
    parser.add_argument(
        '-t',
        '--terminate',
        default=False,
        action='store_true',
    )
    parser.add_argument(
        '--terminate-instance',
        default=True,
    )
    parser.add_argument(
        '--version-platform',
        default='master',
    )
    parser.add_argument(
        '--version-theme',
        default='master',
    )
    arguments = parser.parse_args()
    return arguments

def get_instance(arguments):
    """
    Retrieve an EC2 instance by name
    """
    connection_ec2 = EC2Connection()
    name = "sandbox-instance-{name}".format(
        name=arguments.name,
    )
    instances = connection_ec2.get_only_instances(
        filters={
            'tag:Name': name,
            'tag:Deployment': 'sandbox',
        },
    )
    instances = [
        instance
        for instance in instances
        if instance.state != 'terminated'
    ]
    len_instances = len(instances)
    assert len(instances) <= 1
    if len_instances == 1:
        instance = instances[0]
    else:
        instance = None
    return instance


def create_instance(arguments):
    """
    Provision and deploy a new sandbox instance

    Warning: You must update the `ANSIBLE_CONFIG` environment setting
    _before_ you import `ansible`.
    """
    os.environ['ANSIBLE_CONFIG'] = os.path.join(PATH_PLAYBOOKS, 'ansible.cfg')
    import ansible
    from ansible.inventory import Inventory
    from ansible.playbook import PlayBook
    stats = ansible.callbacks.AggregateStats()
    callbacks = ansible.callbacks.PlaybookCallbacks(
        verbose=ansible.utils.VERBOSITY,
    )
    runner_callbacks = ansible.callbacks.PlaybookRunnerCallbacks(
        stats,
        verbose=ansible.utils.VERBOSITY,
    )
    inventory = Inventory(host_list=os.path.join(PATH_PROJECT, 'stanford', 'ec2.py'))
    extra_vars = {
        'name_tag': arguments.name,
        'edx_platform_version': arguments.version_platform,
        'edxapp_theme_version': arguments.version_theme,
        'edxapp_theme_source_repo': arguments.repo_theme,
        'edx_platform_repo': arguments.repo_platform,
        'keypair': arguments.keypair,
        'terminate_instance': arguments.terminate_instance,
        'ami': arguments.ami,
        'root_ebs_size': arguments.disk_size,
    }
    play = PlayBook(
        playbook=arguments.playbook,
        extra_vars=extra_vars,
        inventory=inventory,
        callbacks=callbacks,
        runner_callbacks=runner_callbacks,
        remote_user='ubuntu',
        stats=stats,
    )
    play.run()
    callbacks.on_stats(play.stats)


def list_instance(arguments):
    """
    Fetch an instance and output a summary
    """
    instance = get_instance(arguments)
    if not instance:
        print('No such instance!', arguments)
        return None
    print(instance.tags)
    name = instance.tags['Name']
    name = name.split('-')[-1]
    dns = name + '-sandbox.class.stanford.edu'
    print('name', name)
    print('id', instance.id)
    print('id', instance.state)
    print('tags', instance.tags)
    print('instance_type', instance.instance_type)
    print('private_ip_address', instance.private_ip_address)
    print('public_dns_name', instance.public_dns_name)
    print('dns', dns)
    return instance


def update_instance(action, state_complete, arguments, dry_run=False):
    """
    Fetch an instance and update its state
    """
    instance = get_instance(arguments)
    actionable = getattr(instance, action)
    actionable(dry_run=dry_run)
    instance = get_instance(arguments)
    while instance.state != state_complete:
        sys.stdout.write('.')
        sys.stdout.flush()
        time.sleep(1)
        instance.update()
    sys.stdout.write('\n')
    sys.stdout.flush()
    return instance


def main(arguments):
    """
    Implement CRUD operations
    """
    if arguments.stop:
        update_instance('stop', 'stopped', arguments)
    if arguments.terminate:
        update_instance('terminate', 'terminated', arguments)
    if arguments.create:
        create_instance(arguments)
    if arguments.start:
        update_instance('start', 'running', arguments)
    if arguments.list:
        list_instance(arguments)


if __name__ == '__main__':
    ARGUMENTS = parse_arguments()
    main(ARGUMENTS)
